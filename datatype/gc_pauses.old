// Copyright 2016 Arsham Shirvani <arshamshirvani@gmail.com>. All rights reserved.
// Use of this source code is governed by the Apache 2.0 license
// License that can be found in the LICENSE file.

package datatype

import (
    "fmt"
    "time"
)

const nsInMs = float64(time.Millisecond)

type pauseData struct {
    lastSampleTime time.Time
    lastPauseNs    float64
    lastNumGc      uint32
}

// map of the app name to the data
var applications map[string]*pauseData

func init() {
    applications = make(map[string]*pauseData)
}

// AppPauseData returns the instance responsible for the pause data.
func AppPauseData(name string) (app *pauseData) {
    var ok bool
    if app, ok = applications[name]; !ok {
        app = &pauseData{
            lastSampleTime: time.Now(),
            lastPauseNs:    0,
            lastNumGc:      0,
        }
        applications[name] = app
    }
    return
}

func (p *pauseData) Values(numGC uint32, totalNS, frequncy float64, paueNS []uint64) {

    now := time.Now()

    // totalPause := float64(totalNS) / nsInMs //????
    // fmt.Println("totalPause:", totalPause)

    // if p.lastPauseNs > 0 {
    //     pauseSinceLastSample := totalNS - p.lastPauseNs
    //     pausePerSecond := float64(pauseSinceLastSample) / nsInMs / frequncy //???
    //     fmt.Println("pausePerSecond:", pausePerSecond)
    // }
    p.lastPauseNs = totalNS

    countGc := int(numGC - p.lastNumGc)
    if p.lastNumGc > 0 {
        diff := float64(countGc)
        diffTime := now.Sub(p.lastSampleTime).Nanoseconds()
        gcPerNanoSec := diff / float64(diffTime) //????
        fmt.Println("gcPerNanoSec:", gcPerNanoSec)
    }

    if countGc > 0 {
        if countGc > 256 {
            countGc = 256
        }

        for i := 0; i < countGc; i++ {
            idx := int((numGC-uint32(i))+255) % 256
            pause := float64(paueNS[idx])
            // r.Aggregate(fmt.Sprintf("%s.memory.gc.pause", prefix), pause/nsInMs, context, dimensions)
            fmt.Println("gc.pause:", pause/nsInMs)
            // _ = pause
        }
    }

    p.lastNumGc = numGC
    p.lastSampleTime = now

}
